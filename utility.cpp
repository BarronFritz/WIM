#include "utility.h"

QStringList splitRackString(const QString &rs)
{
    QString tmpAR, tmpB = "", tmpS = "";
    QStringList ret;
    bool sec = true;

    foreach (QChar c, rs) {
        if(c.isLetter() && sec)
            tmpS.append(c);
        else if(c.isLetter() && !sec)
            tmpB.append(c);
        if(c.isDigit())
        {
            sec = false;
            tmpAR.append(c);
        }
    }

    ret.push_back(tmpS);

    switch(tmpAR.length())
    {
    case 3:
        ret.push_back(tmpAR.mid(0,1));
        ret.push_back(tmpAR.mid(1,2));
        break;
    case 4:
        ret.push_back(tmpAR.mid(0,2));
        ret.push_back(tmpAR.mid(2,2));
        break;
    default:
        ret.push_back("");
        ret.push_back("");
        break;
    }


    ret.push_back(tmpB);

    return ret;
}


QDate string_to_date(const QString &dateString) {
    QDate date;
    QStringList list;

    list.push_back("yyyy-MM-dd");   // 0
    list.push_back("yyyy-MM-d");    // 1
    list.push_back("yyyy-M-dd");    // 2
    list.push_back("yyyy-M-d");     // 3
    list.push_back("M-d-yy");       // 4
    list.push_back("M/d/yy");       // 5
    list.push_back("M-d-yyyy");     // 6
    list.push_back("M/d/yyyy");     // 7
    list.push_back("M-dd-yy");      // 8
    list.push_back("M/dd/yy");      // 9
    list.push_back("M-dd-yyyy");    // 10
    list.push_back("M/dd/yyyy");    // 11
    list.push_back("MM-d-yy");      // 12
    list.push_back("MM/d/yy");      // 13
    list.push_back("MM-d-yyyy");    // 14
    list.push_back("MM/d/yyyy");    // 15
    list.push_back("MM-dd-yy");     // 16
    list.push_back("MM/dd/yy");     // 17
    list.push_back("MM-dd-yyyy");   // 18
    list.push_back("MM/dd/yyyy");   // 19


    list.push_back("M-d");          // 20
    list.push_back("M-d");          // 21
    list.push_back("MM/d");         // 22
    list.push_back("MM/d");         // 23
    list.push_back("M/dd");         // 24
    list.push_back("M/dd");         // 25
    list.push_back("MM/dd");        // 26
    list.push_back("MM/dd");        // 27

    for (QString &format : list)
    {
        date = QDate::fromString(dateString, format);

        if(date.year() == QDate().year()) {
            // if Year is not set
            date.addYears(QDate::currentDate().year() - date.year());
        }
        if(date.isValid()){
            if(date.year() < 2000)
                date = date.addYears(100);
            return date;
        }
    }

    return date;
}

namespace security {

// Returns a Hex encoded psudo random salt hash as a QString
QString generateNewSaltHash(const QString &username) {
    QString psudoRandomSalt =
            QString::number(qrand()) + username + QString::number(qrand());
    QByteArray saltHashByteArray =
            QCryptographicHash::hash(psudoRandomSalt.toLatin1(),
                                     QCryptographicHash::Sha1);
    return QString(saltHashByteArray.toHex());
}

// Returns a Hex encoded password hash generated by adding the saltHash as a QString
QString generateNewPasswordHash(const QString &password, const QString &saltHash) {
    QString saltedPassword = password + saltHash;
    QByteArray passwordHashByteArray =
            QCryptographicHash::hash(saltedPassword.toLatin1(),
                                     QCryptographicHash::Sha1);
    return QString(passwordHashByteArray.toHex());
}

void insertUserIntoDatabase(QSqlDatabase &db, const QString &username, const QString &password,
                            int securityLevel) {
    QString saltHash = generateNewSaltHash(username);
    QString passwordHash = generateNewPasswordHash(password, saltHash);
    if (db.isOpen() || db.open()) {
        QSqlQuery query;
        if (query.prepare("SELECT username FROM login WHERE username = :un")) {
            query.bindValue(":un", username);
            if (query.exec()) {
                query.first();
                if (query.value("username") == username) {
                    // User already exists.
                } else {
                    if (query.prepare("INSERT INTO login( "
                                      "username, password, salt, security) "
                                      "VALUES ( :un , :pw , :sa , :se )")) {
                        query.bindValue(":un", username);
                        query.bindValue(":pw", passwordHash);
                        query.bindValue(":sa", saltHash);
                        query.bindValue(":se", securityLevel);
                        if (query.exec()) {
                            // Value Inserted
                        } else {
                            // DB open, could not execute prepared query
                        }
                    } else {
                        // DB open, could not prepare query
                    }
                }
            } else {
                // DB open, could not execute prepared query
            }
        } else {
            // DB open, could not prepare query
        }
        db.close();
    } else {
        // DB could not be opened
    }
}

bool passwordMatchesHash(const QString &password, const SecLogin &login) {
    QString passwordHash = generateNewPasswordHash(password, login.saltHash);
    return passwordHash == login.passHash;
}

SecLogin getLoginInformation(QSqlDatabase &db, const QString &username, const QString &password) {
    SecLogin login;
    if (db.isOpen() || db.open()) {
        QSqlQuery query;
        if (query.prepare("SELECT username, password, salt, security "
                          "FROM login WHERE username = :un ")) {
            query.bindValue(":un", username);
            if (query.exec()) {
                if (query.first()) {
                    if (query.value("username") == username) {
                        login.username = username;
                        login.passHash = query.value("password").toString();
                        login.saltHash = query.value("salt").toString();
                        login.security = query.value("security").toInt();
                    } else {
                        qDebug() << "Query not located on valid result";
                        // DB Open, query not located on valid result
                    }
                } else {
                    qDebug() << "DB Open, query cannot get results";
                    qDebug() << query.lastError().text();
                    // DB Open, query cannot get results
                }
            } else {
                qDebug() << "DB Open, query cannot execute";
                qDebug() << query.lastError().text();
                // DB Open, query cannot execute
            }
        } else {
            qDebug() << "DB Open, query was not prepared";
            qDebug() << query.lastError().text();
            // DB Open, query was not prepared
        }
        db.close();
    } else {
        qDebug() << "DB could not open";
        qDebug() << db.lastError().text();
        // DB could not be opened
    }

    if (login.isValid() && passwordMatchesHash(password, login)) {
        return login;
    }
    return SecLogin();
}

void printLoginDetails(const SecLogin &login) {
    qDebug() << "Username: " << login.username;
    qDebug() << "Password: " << login.passHash;
    qDebug() << "SaltHash: " << login.saltHash;
    qDebug() << "LoginSec: " << login.security;
}

void markUserForPasswordReset(QSqlDatabase &db, const QString &username) {
    if (db.open()) {
        QSqlQuery query;
        if (query.prepare("UPDATE login SET salt = :sa WHERE username = :un ")) {
            query.bindValue(":sa", QString());
            query.bindValue(":un", username);
            if (query.exec()) {
                // Salt cleared
            } else {
                // DB open, query failed to execute
            }
        } else {
            // DB open, query failed to prepare
        }
        db.close();
    } else {
        // DB failed to open
    }
}

void resetPasswordMarkedForReset(QSqlDatabase &db, const QString &username,
                                 const QString &password) {
    QString newSaltHash = generateNewSaltHash(username);
    QString newPasswordHash = generateNewPasswordHash(password, newSaltHash);
    if (db.isOpen() || db.open()) {
        QSqlQuery query;
        if (query.prepare("UPDATE login SET password = :pw , salt = :sa "
                          "WHERE username = :un ")) {
            query.bindValue(":pw", newPasswordHash);
            query.bindValue(":sa", newSaltHash);
            query.bindValue(":un", username);
            if (query.exec()) {
                // Query Executed, User info changed.
            } else {
                // DB open, could not execute query
            }
        } else {
            // DB open, could not prepare query
        }
        db.close();
    } else {
        // DB could not be opened
    }
}

} // End namespace Security
